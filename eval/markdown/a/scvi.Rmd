---
title: "scvi"
author: "zm"
date: "2024-05-19"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
set.seed(42)
```

this markdown is designed to be run_all

analysis/
├─ markdown/
├─ scripts/
│  ├─ bash/
│  ├─ r/
data/
├─ meta/
├─ processed/
├─ raw/
output/
├─ plots/

```{r sync, eval=FALSE, include=FALSE}
# placeholder
stornext_path <-
  "/stornext/Bioinf/data/lab_brain_cancer/projects/pdo_pdn_comparison/"
vast_path <-
  "vast/scratch/users/moore.z/pdo_pdn_comparison"
system2(
  command = "sbatch",
  args = paste(
    stornext_path,
    "analysis", "scripts", "bash", "rsync_stornext_to_vast.slurm",
    sep = "/"
  )
)
```

```{r here}
# https://twitter.com/hadleywickham/status/940021008764846080
library(here)
```

```{r libraries}
suppressPackageStartupMessages({
  library(BiocParallel)
  library(SingleCellExperiment)
  # last to avoid conflicts
  library(tidyverse)
})
```

```{r scripts}
# source all within folder
walk(
  .x = list.files(
    path = here("analysis", "scripts", "r"),
    full.names = TRUE
  ),
  .f = source
)
```

```{r params}
add_ensembl <- FALSE
annotate_data <- TRUE
```

```{r names}
# extract names from folders
sample_names <- list.dirs(
  path = here("data", "raw"),
  recursive = FALSE
) |>
  str_subset(pattern = "GL") |>
  basename()

sample_groups <- sample_names |>
  str_extract(
    pattern = "[^_]+"
  )

sample_list <- list(
  sample_names[1:3],
  sample_names[4:6],
  sample_names[7:9],
  sample_names[10:12]
) |>
  set_names(
    sample_groups[1],
    sample_groups[4],
    sample_groups[7],
    sample_groups[10],
  )
```

```{r import}
sce_scvi <- map(
  .x = unique(sample_groups),
  .f = function(x) {
    zellkonverter::readH5AD(
      file = here("data", "processed", "scvi", paste0(x, "_scvi.h5ad"))
    )
  }
) |>
  set_names(unique(sample_groups))

map(
  .x = sce_scvi,
  .f = function(sce) {
    plot_umap_coldata(
      obj = sce,
      dimred = "X_scVI_MDE",
      coldata = "sample",
      sample_name = "name",
      width = 10,
      height = 10,
      units = "cm"
    ) +
      ggtitle(label = "scVI-Integrated")
  }
) |>
  patchwork::wrap_plots(ncol = 2)
```

```{r annotate_scvi}
if (FALSE) {
  # start with refs
  # load each reference
  ref_list <- load_ref_list()

  hvgs_reference <- map(
    .x = ref_list,
    .f = function(ref) {
      scran::modelGeneVar(
        x = ref,
        # gotta go fast
        BPPARAM = MulticoreParam(
          workers = length(parallelly::availableWorkers()) / length(ref_list)
        )
      ) |>
        scran::getTopHVGs(n = 5000)
    }
  )

  hvgs_scvi <- map(
    .progress = TRUE,
    .x = sce_scvi,
    .f = function(sce) {
      scran::modelGeneVar(
        x = sce,
        BPPARAM = MulticoreParam(
          workers = length(parallelly::availableWorkers())
        )
      ) |>
        scran::getTopHVGs(n = 5000)
    }
  )

  # let us generalise
  annotation_tib_scvi <- crossing(
    names(sce_scvi),
    names(ref_list)
  ) |>
    rename(test = 1, ref = 2)

  # justin
  gc()

  # could make this faster if we wanted?
  pred <- pmap(
    .progress = TRUE,
    .l = list(
      test = annotation_tib_scvi$test,
      ref = annotation_tib_scvi$ref
    ),
    .f = function(test, ref) {
      # intersect genes
      test_sce <- sce_scvi[[test]]
      ref_sce <- ref_list[[ref]]
      gene_intersect <- intersect(
        x = rownames(test_sce),
        y = rownames(ref_sce)
      )
      # intersect hvgs
      hvgs_test <- hvgs_scvi[[test]]
      hvgs_ref <- hvgs_reference[[ref]]
      hvgs_intersect <- intersect(
        x = hvgs_test,
        y = hvgs_ref
      )

      anno <- case_when(
        ref == "couturier" ~ "cluster",
        ref == "ruiz_moreno" ~ "annotation_level_3"
      )

      # run
      SingleR::SingleR(
        test = test_sce[gene_intersect, ],
        ref = ref_sce[gene_intersect, ],
        restrict = hvgs_intersect,
        labels = colData(ref_sce)[, anno],
        de.method = "wilcox",
        # gotta go fast
        BPPARAM = MulticoreParam(
          workers = length(parallelly::availableWorkers())
        )
      )
    }
  )

  annotation_tib_scvi <- annotation_tib_scvi |>
    mutate(pred = pred) |> 
    mutate(
      pred_tib = map(
        .x = pred,
        .f = as_tibble, rownames = "barcode"
      )
    )

  saveRDS(
    object = annotation_tib_scvi,
    file = here("data", "processed", "annotation_tib_scvi.rds")
  )
} else if (file.exists(here("data", "processed", "annotation_tib_scvi.rds"))) {
  annotation_tib_scvi <- readRDS(
    file = here("data", "processed", "annotation_tib_scvi.rds")
  )
}

# extract all labels into list
annotate_label_list_scvi <- map(
  .x = unique(annotation_tib_scvi$test),
  .f = function(test) {
    ref <- annotation_tib_scvi |>
      filter(test == !!test) |>
      pull(ref)
    # nested jank
    map(
      .x = unique(ref),
      .f = function(ref_unique) {
        annotation_tib_scvi |>
          filter(
            test == !!test,
            ref == !!ref_unique
          ) |>
          unnest(cols = "pred_tib") |>
          select(barcode, pruned.labels) |>
          rename(
            !!paste0(ref_unique, "_labels_scvi") := pruned.labels
          )
      }
    ) |>
      reduce(.f = left_join)
  }
) |>
  set_names(nm = names(sce_scvi))

# add in
sce_scvi <- imap(
  .progress = TRUE,
  .x = sce_scvi,
  .f = function(sce, i) {
    colData(sce) <- colData(sce) |>
      as_tibble() |>
      # as_tibble(rownames = "barcode") |>
      cbind(
        annotate_label_list_scvi[[i]]
      ) |>
      DataFrame()
    sce
  }
)

# new colours
# brain lab wiki doesn't include all
new_annotation_colours <- Polychrome::createPalette(
  N = bind_rows(annotate_label_list_scvi) |>
    pivot_longer(cols = -barcode, values_to = "annotation") |>
    pull(annotation) |>
    unique() |>
    length(),
  seedcolors = c("#ff0000", "#00ff00", "#0000ff")
) |>
  set_names(
    bind_rows(annotate_label_list_scvi) |>
      pivot_longer(cols = -barcode, values_to = "annotation") |>
      pull(annotation) |>
      unique()
  )

# # quick looksie
walk(
  .x = c(
    "couturier_labels_scvi"
    # "ruiz_moreno_labels_scvi"
    ),
  .f = function(label) {
    map(
      .x = names(sample_list),
      .f = function(sample) {
        # we need to go deeper
        map(
          .x = sample,
          .f = function(i) {
            p <- plot_umap_coldata(
              obj = sce_scvi[[i]],
              coldata = label,
              dimred = "X_scVI_MDE",
              sample_name = i,
              colours = new_annotation_colours,
              width = 7.5,
              height = 7.5,
              units = "cm"
            )
            p + ggtitle(
              label = i
            ) +
              ggh4x::force_panelsizes(
                rows = unit(7.5, "cm"),
                cols = unit(7.5, "cm")
              )
            # title append
            # p + ggtitle(
            #   label = paste(
            #     i,
            #     p$labels$title,
            #     sep = "\n"
            #   )
            # )
          }
        ) |>
          patchwork::wrap_plots(nrow = 1)
      }
    ) |>
      patchwork::wrap_plots(ncol = 4) |>
      ggsave(
        filename =
          here("output", "plots", "4_raw_anno_scvi", paste0("raw_", label, ".pdf")),
        device = cairo_pdf,
        width = 50,
        height = 50,
        units = "cm"
      )
    # trim
    system2(
      command = "pdfcrop",
      args = c(
        here("output", "plots", "4_raw_anno_scvi", paste0("raw_", label, ".pdf")),
        here("output", "plots", "4_raw_anno_scvi", paste0("raw_", label, ".pdf"))
      ),
      stdout = NULL
    )
  }
)
```

```{r cluster}
hvgs_sample <- map(
  .progress = TRUE,
  .x = sce_scvi,
  .f = function(sce) {
    scran::modelGeneVar(
      x = sce,
      BPPARAM = MulticoreParam(
        workers = length(parallelly::availableWorkers())
      )
    ) |>
      scran::getTopHVGs(n = 2500)
  }
)

sce_scvi <- imap(
  .progress = TRUE,
  .x = sce_scvi,
  .f = function(sce, i) {
    # default calc is 50
    sce <- scater::runPCA(
      x = sce,
      ncomponents = 50,
      subset_row = hvgs_sample[[i]],
      BSPARAM = BiocSingular::IrlbaParam()
      # BPPARAM = MulticoreParam(
      #   workers = length(parallelly::availableWorkers())
      # )
    )
    # estimate dims
    dim_est <- intrinsicDimension::maxLikGlobalDimEst(
      data = reducedDims(sce)$PCA,
      k = 50,
      unbiased = TRUE
    ) |>
      unlist() |>
      unname() |>
      round()

    # this will (always) be lower than 50
    # redundant? just call runPCA with dim_est?
    # print(dim_est)
    max_dims <- min(50, dim_est)

    # modify in place
    reducedDim(sce, "PCA") <- reducedDim(sce, "PCA")[, 1:max_dims]

    sce <- scater::runUMAP(
      x = sce,
      dimred = "X_scVI",
      # ncomponents = max_dims,
      n_neighbors = 20,
      spread = 3,
      min_dist = 0.05,
      BPPARAM = MulticoreParam(
        workers = length(parallelly::availableWorkers())
      )
    )
    # tsne here if wanted
    # return
    sce
  }
)

cluster_list_scvi <- map(
  .progress = TRUE,
  .x = sce_scvi,
  .f = function(sce) {
    clusters <- scran::clusterCells(
      x = sce,
      use.dimred = "UMAP",
      BLUSPARAM = bluster::NNGraphParam(
        k = 15,
        type = "rank",
        cluster.fun = "louvain"
      ),
      # BPPARAM = MulticoreParam(
      #   workers = length(parallelly::availableWorkers())
      # )
    )
  }
)

sce_scvi <- imap(
  .x = sce_scvi,
  .f = function(sce, i) {
    colData(sce)$cluster <- cluster_list_scvi[[i]]
    # return
    sce
  }
)

cluster_plots_scvi <- imap(
  .x = sce_scvi,
  .f = function(sce, i) {
    plot_umap_coldata(
      obj = sce,
      dimred = "UMAP",
      coldata = "cluster",
      sample_name = i,
      width = 10,
      height = 10,
      units = "cm"
    )
  }
)
cluster_plots_scvi
```

```{r annotate_scvi_cluster}
if (FALSE) {
  # start with refs
  # load each reference
  ref_list <- load_ref_list()

  hvgs_reference <- map(
    .x = ref_list,
    .f = function(ref) {
      scran::modelGeneVar(
        x = ref,
        # gotta go fast
        BPPARAM = MulticoreParam(
          workers = length(parallelly::availableWorkers()) / length(ref_list)
        )
      ) |>
        scran::getTopHVGs(n = 5000)
    }
  )

  hvgs_scvi <- map(
    .progress = TRUE,
    .x = sce_scvi,
    .f = function(sce) {
      scran::modelGeneVar(
        x = sce,
        BPPARAM = MulticoreParam(
          workers = length(parallelly::availableWorkers())
        )
      ) |>
        scran::getTopHVGs(n = 5000)
    }
  )

  # let us generalise
  annotation_tib_scvi_cluster <- crossing(
    names(sce_scvi),
    names(ref_list)
  ) |>
    rename(test = 1, ref = 2)

  # justin
  gc()

  # could make this faster if we wanted?
  pred <- pmap(
    .progress = TRUE,
    .l = list(
      test = annotation_tib_scvi_cluster$test,
      ref = annotation_tib_scvi_cluster$ref
    ),
    .f = function(test, ref) {
      # intersect genes
      test_sce <- sce_scvi[[test]]
      ref_sce <- ref_list[[ref]]
      # gene_intersect <- intersect(
      #   x = rownames(test_sce),
      #   y = rownames(ref_sce)
      # )
      # # intersect hvgs
      # hvgs_test <- hvgs_scvi[[test]]
      # hvgs_ref <- hvgs_reference[[ref]]
      # hvgs_intersect <- intersect(
      #   x = hvgs_test,
      #   y = hvgs_ref
      # )

      anno <- case_when(
        ref == "couturier" ~ "cluster",
        ref == "ruiz_moreno" ~ "annotation_level_3"
      )

      # run
      SingleR::SingleR(
        test = test_sce,
        ref = ref_sce,
        # restrict = hvgs_intersect,
        labels = colData(ref_sce)[, anno],
        de.method = "wilcox",
        clusters = colData(test_sce)[, "cluster"],
        # gotta go fast
        BPPARAM = MulticoreParam(
          workers = length(parallelly::availableWorkers())
        )
      )
    }
  )

  annotation_tib_scvi_cluster <- annotation_tib_scvi_cluster |>
    mutate(
      pred_tib = map(
        .x = pred,
        .f = as_tibble, rownames = "cluster"
      )
    )

  saveRDS(
    object = annotation_tib_scvi_cluster,
    file = here("data", "processed", "annotation_tib_scvi_cluster.rds")
  )
} else if (file.exists(here("data", "processed", "annotation_tib_scvi_cluster.rds"))) {
  annotation_tib_scvi_cluster <- readRDS(
    file = here("data", "processed", "annotation_tib_scvi_cluster.rds")
  )
}

# extract all labels into list
annotate_label_list_scvi_cluster <- map(
  .x = unique(annotation_tib_scvi_cluster$test),
  .f = function(test) {
    ref <- annotation_tib_scvi_cluster |>
      filter(test == !!test) |>
      pull(ref)
    # nested jank
    map(
      .x = unique(ref),
      .f = function(ref_unique) {
        annotation_tib_scvi_cluster |>
          filter(
            test == !!test,
            ref == !!ref_unique
          ) |>
          unnest(cols = "pred_tib") |>
          rename(cluster = barcode) |>
          select(cluster, pruned.labels) |>
          rename(
            !!paste0(ref_unique, "_cluster_labels_scvi") := pruned.labels
          )
      }
    ) |>
      reduce(.f = left_join)
  }
) |>
  set_names(nm = names(sce_scvi))

# add in
sce_scvi <- imap(
  .progress = TRUE,
  .x = sce_scvi,
  .f = function(sce, i) {
    colData(sce) <- colData(sce) |>
      as_tibble() |>
      # as_tibble(rownames = "barcode") |>
      left_join(
        annotate_label_list_scvi_cluster[[i]],
        by = "cluster"
      ) |>
      DataFrame()
    sce
  }
)

# new colours
# brain lab wiki doesn't include all
new_annotation_colours <- Polychrome::createPalette(
  N = bind_rows(annotate_label_list_scvi) |>
    pivot_longer(cols = -barcode, values_to = "annotation") |>
    pull(annotation) |>
    unique() |>
    length(),
  seedcolors = c("#ff0000", "#00ff00", "#0000ff")
) |>
  set_names(
    bind_rows(annotate_label_list_scvi) |>
      pivot_longer(cols = -barcode, values_to = "annotation") |>
      pull(annotation) |>
      unique()
  )

# # quick looksie
map(
  .x = c("couturier_cluster_labels_scvi", "ruiz_moreno_cluster_labels_scvi"),
  .f = function(label) {
    map(
      .x = names(sample_list),
      .f = function(sample) {
        # we need to go deeper
        map(
          .x = sample,
          .f = function(i) {
            p <- plot_umap_coldata(
              obj = sce_scvi[[i]],
              coldata = label,
              dimred = "UMAP",
              sample_name = i,
              colours = new_annotation_colours,
              width = 7.5,
              height = 7.5,
              units = "cm"
            )
            p + ggtitle(
              label = i
            ) +
              ggh4x::force_panelsizes(
                rows = unit(7.5, "cm"),
                cols = unit(7.5, "cm")
              )
            # title append
            # p + ggtitle(
            #   label = paste(
            #     i,
            #     p$labels$title,
            #     sep = "\n"
            #   )
            # )
          }
        ) |>
          patchwork::wrap_plots(nrow = 1)
      }
    )
    #   patchwork::wrap_plots(ncol = 4) |>
    #   ggsave(
    #     filename =
    #       here("output", "plots", "4_raw_anno_scvi", paste0("raw_", label, ".pdf")),
    #     device = cairo_pdf,
    #     width = 50,
    #     height = 50,
    #     units = "cm"
    #   )
    # # trim
    # system2(
    #   command = "pdfcrop",
    #   args = c(
    #     here("output", "plots", "4_raw_anno_scvi", paste0("raw_", label, ".pdf")),
    #     here("output", "plots", "4_raw_anno_scvi", paste0("raw_", label, ".pdf"))
    #   ),
    #   stdout = NULL
    # )
  }
)
```

```{r}
imap(
  .x = sce_scvi[1],
  # .x = sce_list,
  .f = function(sce, i) {
    imap(
      .x = tumour_sets_ms,
      .f = function(x, j) {
        # print(j)
        # k <<- j
        # assign(x = "j", value = j, envir = globalenv())
        list(
          plot_umap_coldata(
            obj = sce,
            coldata = "cluster",
            sample_name = i,
            width = 7.5,
            height = 7.5,
            units = "cm"
          )
        ) |>
          append(
            map(
              .x = x,
              .f = function(y) {
                plot_umap_gene(
                  obj = sce,
                  gene_name = y,
                  sample_name = i,
                  width = 7.5,
                  height = 7.5,
                  units = "cm"
                )
              }
            )
          ) |>
          patchwork::wrap_plots(ncol = 4)
      }
    )
  }
)
```

```{r markers}
marker_list_scvi <- map(
  .progress = TRUE,
  .x = sce_scvi,
  .f = function(sce) {
    list <- scran::findMarkers(
      x = sce,
      groups = sce$cluster,
      test.type = "wilcox",
      pval.type = "all"
    ) |>
      as.list()

    map(
      .x = list,
      .f = function(x) {
        x |>
          as_tibble(rownames = "gene_id") |>
          left_join(
            y = rowData(sce) |>
              as_tibble() |>
              select(gene_id, gene_name),
            by = "gene_id"
          ) |>
          relocate(gene_name, .after = gene_id)
      }
    )
  }
)

marker_plots_scvi <- map(
  .progress = TRUE,
  .x = names(sce_scvi),
  .f = function(x) {
    expr_plots <- map(
      .x = 1:length(unique(sce_scvi[[x]]$cluster)),
      .f = function(y) {
        top_genes_to_plot <- marker_list_scvi[[x]][[y]] |>
          head(9) |>
          select(gene_id, gene_name) |> 
          mutate(gene_name = as.character(gene_name))

        p <- scater::plotExpression(
          object = sce_scvi[[x]],
          features = top_genes_to_plot$gene_id,
          x = "cluster",
          colour_by = "cluster"
        ) +
          theme(
            # aspect.ratio = 1,
            axis.title.y = element_blank(),
            legend.position = "none",
            plot.title = element_text(face = "plain")
          ) +
          ggtitle(label = paste("cluster", y)) +
          ggh4x::facet_wrap2(
            drop = FALSE,
            ~Feature,
            labeller = as_labeller(
              # named vector
              deframe(top_genes_to_plot)
            )
          )
        # p <- egg::set_panel_size(
        #   p,
        #   width = unit(2.5, "cm"),
        #   height = unit(2.5, "cm")
        #   ) |>
        # ggplotify::as.ggplot()
        p
      }
    )
    umap_plot <- scater::plotReducedDim(
      object = sce_scvi[[x]],
      dimred = "X_scVI_MDE",
      colour_by = "cluster"
    ) +
      theme(
        # aspect.ratio = 1,
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(face = "plain")
      ) +
      ggtitle(label = x)

    # align
    # patchwork::wrap_plots(
    append(
      list(umap_plot),
      expr_plots
    )
    # )
  }
) |>
  set_names(names(sce_scvi)) |>
  # this feels jank
  # separate because this takes time - why??
  map(
    .progress = TRUE,
    # .x = marker_plots,
    .f = function(plots) {
      p <- plots |>
        # align
        patchwork::wrap_plots(ncol = 4) |>
        # now the aligned plot is single plot and loses facets
        ggplotify::as.ggplot()
      # calc n_rows for final plot size
      n_rows <- ceiling(
        length(plots) / 4
      )
      p + ggh4x::force_panelsizes(
        rows = unit(x = n_rows * 15, "cm"),
        cols = unit(60, "cm")
      )
    }
  )
# save
iwalk(
  .progress = TRUE,
  .x = marker_plots_scvi,
  .f = function(x, i) {
    ggsave(
      plot = x,
      filename =
        here("output", "plots", "5_markers", paste0(i, "_marker_genes", ".pdf")),
      device = cairo_pdf,
      width = 100,
      height = 100,
      units = "cm"
    )
    # trim
    system2(
      command = "pdfcrop",
      args = c(
        here("output", "plots", "5_markers", paste0(i, "_marker_genes", ".pdf")),
        here("output", "plots", "5_markers", paste0(i, "_marker_genes", ".pdf"))
      ),
      stdout = NULL
    )
  }
)
```

```{r scevan}
scevan_res <- imap(
  .progress = TRUE,
  .x = sce_scvi,
  .f = function(sce, i) {
    try({
      cat(i, "\n")
      mat <- counts(sce) |>
        as.matrix()
      row.names(mat) <- rowData(sce)$gene_name
      colnames(mat) <- sce$barcode
      mat <- mat[!duplicated(row.names(mat)), ]

      # return
      SCEVAN::pipelineCNA(
        # let's not focus on this now
        # just interested in what is non-malignant
        SUBCLONES = TRUE,
        count_mtx = mat,
        sample = i,
        # beta_vega = 0.75,
        par_cores = length(parallelly::availableWorkers())
      )
    })
  }
)

sce_scvi  <- imap(
  .x = sce_scvi,
  .f = function(sce, i) {
    colData(sce) <- colData(sce) |> 
      as_tibble() |> 
      left_join(
        y = scevan_res[[i]] |> 
          as_tibble(rownames = "barcode") |> 
          select(barcode, class, subclone) |> 
          rename(scevan = class, scevan_sub = subclone),
        by = "barcode"
      ) |> 
      DataFrame()

    sce
  }
)
saveRDS(
  object = scevan_res,
  file = here("data", "processed", "scevan", "scevan_scvi.rds")
)

imap(
  .x = sce_scvi,
  .f = function(sce, i) {
    plot_umap_coldata(
      obj = sce,
      dimred = "UMAP",
      sample_name = i,
      coldata = "scevan.x",
      height = 10,
      width = 10,
      units = "cm"
    )
  }
)
```

```{r CH}
ref_list <- load_ref_list()
ref_list$couturier$cell_class <- ref_list$couturier$cluster |> 
  as.character() |> 
  snakecase::to_snake_case()

rownames(colData(ref_list$couturier)) <- 
  colData(ref_list$couturier)$Barcode

intersect <- intersect(
  rownames(sce_scvi$GL0028),
  rownames(ref_list$couturier)
)

library(CHETAH)

CorrelateReference(
  ref_cells = ref_list$couturier,
  ref_ct = "cell_class",
  ref_c = "logcounts"
  )
ClassifyReference(
  ref_cells = ref_list$couturier,
  ref_ct = "cell_class",
  ref_c = "logcounts"
)
intersect <- intersect(
  x = rownames(ref_list$couturier),
  y = rownames(sce_scvi$GL0095)
)
chetah_res <- CHETAH::CHETAHclassifier(
  input = sce_scvi$GL0095[, ],
  ref_cells = ref_list$couturier[, ],
  input_c = "logcounts",
  ref_c = "logcounts",
  ref_ct = "cell_class",
  cor_method = "pearson",
  clust_method = "median",
  gs_method = "wilcox"
  # n_genes = 500
)
plot_umap_coldata(
  obj = chetah_res,
  dimred = "X_scVI_MDE",
  coldata = "celltype_CHETAH",
  sample_name = "test",
  width = 10,
  height = 10,
  units = "cm"
)
PlotCHETAH(
  input = chetah_res, 
  redD = "X_scVI_MDE",
  interm = TRUE
  )
chetah_res <- Classify(
  input = chetah_res,
  thresh = 0.0
)
```

```{r gsea_couturier}
couturier_gsea <- read_csv(
  file = here("analysis", "diff_gsea.csv"),
  show_col_types = FALSE
)
map(
  .x = 1:length(sce_scvi$GL0095$cluster |> unique()),
  .f = function(x) {
    fgsea::fgsea(
  pathways = list(
    dc2 = couturier_gsea$dc2
    # dc2 = couturier_gsea$dc2,
    # dc3 = couturier_gsea$dc3
    ),
  stats = marker_list_scvi$GL0095[[x]] |> 
    mutate(num = row_number()) |> 
    select(gene_name, num) |> 
    filter(gene_name %in% couturier_gsea$dc2) |> 
    deframe(),
  scoreType = "pos"
)
  }
) |> 
  bind_rows()

hvgs_reference <- map(
    .x = ref_list,
    .f = function(ref) {
      scran::modelGeneVar(
        x = ref,
        # gotta go fast
        BPPARAM = MulticoreParam(
          workers = length(parallelly::availableWorkers()) / length(ref_list)
        )
      ) |>
        scran::getTopHVGs(n = 5000)
    }
  )

couturier <- imap(
  .x = ref_list[2],
  .f = function(sce, i) {
    sce <- scater::runPCA(
      x = sce,
      ncomponents = 50,
      subset_row = hvgs_reference[[i]],
      BSPARAM = BiocSingular::IrlbaParam()
      # BPPARAM = MulticoreParam(
      #   workers = length(parallelly::availableWorkers())
      # )
    )
    # estimate dims
    # dim_est <- intrinsicDimension::maxLikGlobalDimEst(
    #   data = reducedDims(sce)$PCA,
    #   k = 50,
    #   unbiased = TRUE
    # ) |>
    #   unlist() |>
    #   unname() |>
    #   round()

    # this will (always) be lower than 50
    # redundant? just call runPCA with dim_est?
    # print(dim_est)
    # max_dims <- min(50, dim_est)

    # modify in place
    # reducedDim(sce, "PCA") <- reducedDim(sce, "PCA")[, 1:max_dims]

    sce <- scater::runUMAP(
      x = sce,
      dimred = "PCA",
      # ncomponents = max_dims,
      n_neighbors = 20,
      spread = 3,
      min_dist = 0.05,
      BPPARAM = MulticoreParam(
        workers = length(parallelly::availableWorkers())
      )
    )
    sce
  }
)



plot_umap_coldata(
  obj = sce,
  coldata = "Sample",
  sample_name = "couturier",
  width = 15,
  height = 15,
  units = "cm"
)

```


